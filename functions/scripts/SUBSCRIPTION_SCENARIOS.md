# Subscription Lifecycle Scenarios

Script: `functions/scripts/subscription-scenarios.js`

This document defines the scenario test matrix generated by the script, what each scenario updates, and what must be true at the end.

## Scope

The script simulates subscription lifecycle transitions by writing deterministic data into Firestore:

- `organisations/{orgId}`
- `users/{uid}`
- `subscriptions/{uid}`
- `paymentHistory/{docId}`
- `emailQueue/{docId}`
- `userNotifications/{docId}`
- `subscriptionScenarioRuns/{runId}`
- `subscriptionScenarioRuns/{runId}/events/{eventId}`

It is designed for emulator validation and regression testing of:

- trial handling
- conversion and cancellation behavior
- package upgrade/downgrade behavior
- reminder side effects (queue + in-app notification)

## Execution

Run from `/Users/zbynekstrnad/git/A11yScan/functions`:

```bash
FIRESTORE_EMULATOR_HOST=localhost:8080 GCLOUD_PROJECT=accessibilitychecker-c6585 npm run scenarios:subscriptions
```

Optional:

```bash
node scripts/subscription-scenarios.js --orgId=org_sub_test --baseDate=2026-01-01T10:00:00Z
```

Safety override (not recommended):

```bash
node scripts/subscription-scenarios.js --allow-prod
```

## Scenario Reference

### 1. `trial_user_canceled`

Timeline:

- Trial created (`status=trialing`, trial dates set).
- User requests cancellation (`cancelAtPeriodEnd=true`, `cancelAt=trialEnd`).
- End-of-trial cancellation applied (`status=canceled`).

Expected final state:

- `subscriptions/{uid}.status == "canceled"`
- `subscriptions/{uid}.cancelAtPeriodEnd == false`
- `subscriptions/{uid}.canceledAt` exists

### 2. `trial_user_expired`

Timeline:

- Trial created.
- Trial reminder generated 3 days before end:
- `emailQueue` document (`type=trial_will_end`, `status=queued`)
- `userNotifications` document (`type=trial_will_end`)
- Trial expires without payment (`status=expired`).

Expected final state:

- `subscriptions/{uid}.status == "expired"`
- `subscriptions/{uid}.trialEndDate` present and in past relative to end of timeline
- Reminder artifacts exist in `emailQueue` and `userNotifications`

### 3. `trial_user_extended_canceled`

Timeline:

- Trial created.
- Trial extended by 7 days (`trialEndDate` moved, `trialExtendedByDays=7`).
- Cancellation requested for extended end.
- Cancellation executed at extended end.

Expected final state:

- `subscriptions/{uid}.status == "canceled"`
- `subscriptions/{uid}.trialExtendedByDays == 7`
- `subscriptions/{uid}.cancelAtPeriodEnd == false`

### 4. `trial_user_extended_paying`

Timeline:

- Trial created.
- Trial extended by 7 days.
- Converted to paid before trial ends (`status=active`, paid period dates set).
- Payment history entry created.

Expected final state:

- `subscriptions/{uid}.status == "active"`
- `subscriptions/{uid}.packageId == "starter"`
- `subscriptions/{uid}.cancelAtPeriodEnd != true`
- `paymentHistory` contains scenario payment record

### 5. `paying_user_upgrade`

Timeline:

- Paid subscription starts on `starter`.
- Upgrade executed to `professional` (immediate).
- Billing period reset to upgrade timestamp.
- Payment history entry created.

Expected final state:

- `subscriptions/{uid}.status == "active"`
- `subscriptions/{uid}.packageId == "professional"`
- `subscriptions/{uid}.scheduledChange` not present
- `paymentHistory` contains scenario payment record

### 6. `paying_user_downgrade`

Timeline:

- Paid subscription starts on `professional`.
- Downgrade requested to `starter`.
- Downgrade stored as `scheduledChange` for period end.

Expected final state:

- `subscriptions/{uid}.packageId == "professional"` (unchanged until effective date)
- `subscriptions/{uid}.scheduledChange` exists
- `subscriptions/{uid}.scheduledChange.packageId == "starter"`

### 7. `paying_user_cancel_subscription`

Timeline:

- Paid subscription starts.
- Cancellation requested (`cancelAtPeriodEnd=true`, `cancelAt=currentPeriodEnd`).
- Cancellation executed at period end (`status=canceled`).

Expected final state:

- `subscriptions/{uid}.status == "canceled"`
- `subscriptions/{uid}.cancelAtPeriodEnd == false`
- `subscriptions/{uid}.canceledAt` exists

### 8. `limits_current_period_usage_populated`

Timeline:

- Active subscription with starter limits.
- `currentUsage` populated during current billing period.

Expected final state:

- `currentUsage.activeProjects > 0`
- `currentUsage.scansThisMonth > 0`
- `currentUsage.usagePeriodStart` exists

### 9. `limits_enforced_projects_scans`

Timeline:

- Active subscription on basic plan.
- Usage counters set exactly at plan limits.
- Limit checks evaluated for:
- add project
- run scan
- create scheduled scan

Expected final state:

- Add project blocked at limit.
- Run scan blocked at limit.
- Scheduled scan creation blocked at limit.

### 10. `new_period_rollover_usage_snapshot`

Timeline:

- Previous period has non-zero usage.
- New period starts.
- Monthly/day counters reset for new period.
- Previous period snapshot appended to `usageHistory`.

Expected final state:

- `currentUsage.scansThisMonth == 0`
- `currentUsage.apiCallsToday == 0`
- `usageHistory` contains previous period snapshot

### 11. `payment_failed_notified_dashboard_email`

Timeline:

- Active paid subscription.
- Payment failure occurs.
- Subscription moves to `past_due`.
- `paymentRetryCount` increments.
- Notification side effects created:
- `emailQueue` (`type=payment_failed`)
- `userNotifications` (`type=payment_failed`)

Expected final state:

- `subscriptions/{uid}.status == "past_due"`
- `subscriptions/{uid}.paymentRetryCount == 1`
- Payment-failed email is queued.
- Payment-failed in-app notification exists.

## Data Contract Used By Scenarios

Common subscription fields set by scenarios:

- `userId`
- `organizationId`
- `stripeSubscriptionId`
- `status`
- `packageId`
- `packageName`
- `billingCycle`
- `currentPeriodStart`
- `currentPeriodEnd`
- `trialStart`, `trialStartDate`
- `trialEnd`, `trialEndDate`, `trialEndsAt`
- `cancelAtPeriodEnd`
- `cancelAt`
- `canceledAt`
- `scheduledChange`

Reminder side-effect fields:

- `emailQueue.type = "trial_will_end"`
- `emailQueue.status = "queued"`
- `userNotifications.type = "trial_will_end"`
- `userNotifications.level = "warning"`
- `emailQueue.type = "payment_failed"` (payment-failed scenario)
- `userNotifications.type = "payment_failed"` (payment-failed scenario)

Usage rollover target fields:

- `currentUsage.usagePeriodStart`
- `usageHistory[]` snapshots:
- `periodStart`
- `periodEnd`
- `usage.*`
- `capturedAt`

## Assertions And Reporting

The script stores a persistent report:

- `subscriptionScenarioRuns/{runId}`:
- scenario metadata
- pass/fail summary
- per-scenario checks

- `subscriptionScenarioRuns/{runId}/events/*`:
- timeline entries (`action`, `at`, `patch`, `expectation`)

Console output includes:

- PASS/FAIL per scenario
- PASS/FAIL per assertion
- aggregate totals (`passed`, `failed`)

Exit code:

- `0` when all checks pass
- `2` when at least one check fails
- `1` on runtime/script errors
